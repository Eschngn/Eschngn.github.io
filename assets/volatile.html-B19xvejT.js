import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e,o as n}from"./app-JjwaxC0C.js";const t={};function l(d,i){return n(),a("div",null,i[0]||(i[0]=[e(`<p>在 Java 中，<code>volatile</code> 关键字是一个非常重要的非访问控制修饰符，它用于修饰类的成员变量。在多线程环境中，<code>volatile</code> 可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p><p>在 JDK 5 之后 <code>volatile</code> 关键字还具备一定的有序性（Ordering）。</p><p>在了解 <code>volatile</code> 实现原理之前，我们先来看下与其实现原理相关的 CPU 术语与说明，下图摘自 《Java 并发编程的艺术》：</p><figure><img src="https://chengliuxiang.oss-cn-hangzhou.aliyuncs.com/blog/cpu-terminology-and-description.png" alt="相关 CPU 术语与说明" tabindex="0" loading="lazy"><figcaption>相关 CPU 术语与说明</figcaption></figure><h2 id="可见性" tabindex="-1"><a class="header-anchor" href="#可见性"><span>可见性</span></a></h2><p>在多核处理器架构下，每个线程在执行时为了提高效率，通常会从主内存 <code>（Main Memory）</code>中读取共享变量的副本到自己的<strong>工作内存 <code>（Working Memory)</code></strong> 或 CPU 缓存中。线程对变量的所有操作，都是在工作内存中进行的，操作完成后再择机写入主内存。</p><p>内存模型的简单结构如下图所示：</p><figure><img src="https://chengliuxiang.oss-cn-hangzhou.aliyuncs.com/blog/thread-memory.png" alt="线程工作内存和主内存" tabindex="0" loading="lazy"><figcaption>线程工作内存和主内存</figcaption></figure><p>这就带来了一个问题：如果一个线程修改了变量的值，但这个修改还没有被写回主内存，其他线程从自己的工作内存中读取的变量值依然是旧的，这就是可见性问题。</p><p><code>volatile</code> 关键字就是用来解决这个问题的。当一个变量被 <code>volatile</code> 修饰后：</p><ul><li><p>对 <code>volatile</code> 变量的写入操作：会强制将修改后的值立即写回主内存。</p></li><li><p>对 <code>volatile</code> 变量的读取操作：会强制从主内存中读取最新的值，而不是从线程的本地缓存中读取。</p></li></ul><h3 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h3><p>在 Java 中，对被 <code>volatile</code> 修饰的共享变量进行写操作时，JVM 会生成带 <code>lock</code> 前缀的 CPU 指令，<code>lock</code> 指令会触发缓存一致性协议（比如 MESI 协议），将当前处理器缓存行的数据回写到系统内存并使其他 CPU 中缓存的该变量副本失效。</p><p>缓存一致性协议工作原理：处理器通过总线嗅探 <code>（bus snooping）</code> 监听其他处理器对内存的读写，当检测到其他处理器修改了自己缓存行对应的内存地址时，会将该缓存行标记为无效<code>（Invalid）</code>，下次访问时会强制从内存重新读取最新数据。</p><p>早期的 Intel486 和 Pentium 会直接在总线上发出 <code>LOCK#</code> 信号，锁住总线，开销大，新的处理器（ P6 及以后）通常是锁缓存行（缓存锁定）并写回内存，然后利用缓存一致性协议来保证修改的原子性和可见性。</p><p>感受 <code>volatile</code> 可见性的示例代码如下：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> VolatileVisibilityDemo</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> volatile</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> boolean</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> ready </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    private</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> number </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ReaderThread</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        @</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">Override</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">            // 当 ready 变为 true 时，跳出循环</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">            while</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ready) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 如果 ready 没有被 volatile 修饰，这里的循环可能永远不会停止</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                // 因为 ReaderThread 无法感知到主线程对其的修改</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">            }</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">            System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;ReaderThread 结束循环，number = &quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> +</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> number);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> static</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> main</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[] </span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> throws</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> InterruptedException</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ReaderThread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">start</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        Thread</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sleep</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">); </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 确保 ReaderThread 先运行</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        number </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 42</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        ready </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">; </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 写入 volatile 变量，强制刷新到主内存</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">        System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;主线程已修改了 number 和 ready 的值&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出如下：</p><div class="language-tex line-numbers-mode" data-highlighter="shiki" data-ext="tex" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-tex"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">主线程已修改了 number 和 ready 的值</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">ReaderThread 结束循环，number = 42</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 <code>ready</code> 变量没有使用 <code>volatile</code> 修饰，主线程即使修改了 <code>ready</code> 的值，<code>ReaderThread</code> 也无法感知到，会因为其 CPU 缓存中的 <code>ready</code> 一直是 <code>false</code> 而陷入死循环，永远无法结束。</p><p><code>ready</code> 变量使用 <code>volatile</code> 修饰后，主线程线程对 <code>ready</code> 的修改会立即被同步到主内存，<code>ReaderThread</code> 会感知到这个变化，从而结束循环。</p><h2 id="有序性" tabindex="-1"><a class="header-anchor" href="#有序性"><span>有序性</span></a></h2><p>为了提高性能，编译器和处理器可能会对指令进行重排序 <code>（Reordering）</code>。在单线程环境下，这种重排序不会影响最终结果，但在多线程环境下可能会导致意想不到的错误。</p><p><code>volatile</code> 除了保证可见性，还通过在底层插入内存屏障 <code>（Memory Barrier）</code> 来保证有序性，它会禁止特定类型的指令重排序：</p><ul><li><p>当写入一个 <code>volatile</code> 变量时，所有在它之前的普通写操作，都必须先完成，并且将结果刷新到主内存中。</p></li><li><p>当读取一个 <code>volatile</code> 变量时，所有在它之后的普通读写操作，都必须等到读取 <code>volatile</code> 变量的操作完成后才能执行。</p></li></ul><p>这个特性保证了在 <code>volatile</code> 变量之前执行的操作，对其他线程是可见的。</p><p>比如在上面的例子中，<code>number = 42;</code> 的赋值操作，会先于 <code>ready = true;</code> 的写入操作完成，并对 <code>ReaderThread</code> 可见。</p><h2 id="与-synchronized-的区别" tabindex="-1"><a class="header-anchor" href="#与-synchronized-的区别"><span>与 <code>synchronized</code> 的区别</span></a></h2><p><code>volatile</code> 和 <code>synchronized</code> 都是用于解决多线程问题的，但它们有本质上的区别：</p><table><thead><tr><th>特性</th><th><code>volatile</code></th><th><code>synchronized</code></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>主要解决<strong>可见性</strong>和<strong>有序性</strong>问题。</td><td>解决<strong>可见性、有序性</strong>，同时还具备<strong>原子性</strong>。</td></tr><tr><td><strong>原子性</strong></td><td><strong>不保证</strong>原子性。对 <code>volatile</code> 变量的自增（<code>i++</code>）操作不是原子的，它包含读、改、写三个步骤。</td><td><strong>保证</strong>原子性。确保同一时间只有一个线程可以执行同步代码块。</td></tr><tr><td><strong>锁机制</strong></td><td><strong>不提供</strong>任何锁机制，不会阻塞线程。</td><td><strong>提供</strong>锁机制，会阻塞其他线程，开销较大。</td></tr><tr><td><strong>适用范围</strong></td><td>只能修饰<strong>成员变量</strong>。</td><td>可以修饰<strong>方法</strong>和<strong>代码块</strong>。</td></tr><tr><td><strong>使用场景</strong></td><td>适用于那些<strong>一个线程写入、多个线程读取</strong>的<strong>状态标记</strong>或<strong>标志量</strong>。</td><td>适用于需要保证<strong>原子操作</strong>、<strong>数据完整性</strong>的复杂业务逻辑。</td></tr></tbody></table><h2 id="volatile-的正确使用场景" tabindex="-1"><a class="header-anchor" href="#volatile-的正确使用场景"><span><code>volatile</code> 的正确使用场景</span></a></h2><p><code>volatile</code> 关键字非常轻量，它不能替代 <code>synchronized</code> 来保证线程安全。它适用于以下两种情况：</p><ol><li><p>作为状态标志量： 某个线程需要不断检查一个标志位，而另一个线程会改变这个标志位来通知它。</p></li><li><p>单次写入、多次读取的计数器或状态值： 确保一个线程对某个值的修改能立即被其他线程看到，但这个修改本身不需要是原子性的（例如，<code>volatile int status</code>）。</p></li></ol><p>不能使用 <code>volatile</code> 的场景：</p><p><code>volatile</code> 不适用于需要原子性的复合操作，例如 <code>i++</code>。因为 <code>i++</code> 操作分为读取、修改、写入三个步骤，而 <code>volatile</code> 只能保证读和写的可见性，无法保证整个复合操作是原子的。如果多个线程同时执行 <code>i++</code>，仍然会发生竞态条件。在这种情况下，我们需要使用 <code>synchronized</code>、<code>AtomicInteger</code> 等原子类来确保线程安全。</p><p>⚠️注意：上面 <code>volatile</code> 缓存一致性的原子性是 CPU 层面的，在缓存行锁住期间，别的 CPU 对该地址的读写会被阻塞或失效，这样能保证这个变量的读 - 改 - 写（单次内存操作）是不可被打断的，这种原子性是硬件层面保证单条或少数几条机器指令不可分割。</p><p>而 <code>synchronized</code> 的原子性是 JVM 层面的，属于更高层次的并发控制。</p><p>举个例子🌰：</p><p>假设我们有个共享变量 <code>count</code>，多个线程要做 <code>count++</code>：</p><ul><li><strong><code>volatile</code> 修饰的 <code>count</code></strong><ul><li>每次写都会让 CPU 把缓存行回写内存，并让其他 CPU 缓存失效。</li><li>但是 <code>count++</code> 本质是三个步骤： <ol><li>读 <code>count</code></li><li>加 1</li><li>写回 <code>count</code></li></ol></li><li>如果两个线程同时执行，可能都先读到同一个旧值，然后覆盖彼此的结果（数据竞争）。</li><li>因此 <code>volatile</code> 保证可见性，但不能保证这个复合操作的原子性。</li></ul></li><li><strong><code>synchronized</code> 包裹 <code>count++</code></strong><ul><li>一个线程进锁执行完 <code>count++</code> 整个过程后才释放锁。</li><li>另一个线程必须等到锁释放后才能执行，所以结果不会丢失。</li><li>因此 <code>synchronized</code> 保证了整个临界区的原子性。</li></ul></li></ul>`,40)]))}const p=s(t,[["render",l]]),r=JSON.parse(`{"path":"/knowledge-base/java/concurrent/volatile.html","title":"volatile","lang":"zh-CN","frontmatter":{"title":"volatile","category":["Java"],"tag":["Java 并发编程"],"description":"在 Java 中，volatile 关键字是一个非常重要的非访问控制修饰符，它用于修饰类的成员变量。在多线程环境中，volatile 可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 在 JDK 5 之后 volatile 关键字还具备一定的有序性（Orderin...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"volatile\\",\\"image\\":[\\"https://chengliuxiang.oss-cn-hangzhou.aliyuncs.com/blog/cpu-terminology-and-description.png\\",\\"https://chengliuxiang.oss-cn-hangzhou.aliyuncs.com/blog/thread-memory.png\\"],\\"dateModified\\":\\"2025-09-07T06:08:21.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Shawn\\"}]}"],["meta",{"property":"og:url","content":"https://mister-hope.github.io/knowledge-base/java/concurrent/volatile.html"}],["meta",{"property":"og:site_name","content":"Shawn's Blog"}],["meta",{"property":"og:title","content":"volatile"}],["meta",{"property":"og:description","content":"在 Java 中，volatile 关键字是一个非常重要的非访问控制修饰符，它用于修饰类的成员变量。在多线程环境中，volatile 可以保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 在 JDK 5 之后 volatile 关键字还具备一定的有序性（Orderin..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://chengliuxiang.oss-cn-hangzhou.aliyuncs.com/blog/cpu-terminology-and-description.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-07T06:08:21.000Z"}],["meta",{"property":"article:tag","content":"Java 并发编程"}],["meta",{"property":"article:modified_time","content":"2025-09-07T06:08:21.000Z"}]]},"git":{"createdTime":1757225301000,"updatedTime":1757225301000,"contributors":[{"name":"Shawn","username":"Shawn","email":"ScoMorii@163.com","commits":1,"url":"https://github.com/Shawn"}]},"readingTime":{"minutes":6.77,"words":2032},"filePathRelative":"knowledge-base/java/concurrent/volatile.md","excerpt":"<p>在 Java 中，<code>volatile</code> 关键字是一个非常重要的非访问控制修饰符，它用于修饰类的成员变量。在多线程环境中，<code>volatile</code> 可以保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\\n<p>在 JDK 5 之后 <code>volatile</code> 关键字还具备一定的有序性（Ordering）。</p>\\n<p>在了解 <code>volatile</code> 实现原理之前，我们先来看下与其实现原理相关的 CPU 术语与说明，下图摘自 《Java 并发编程的艺术》：</p>","autoDesc":true}`);export{p as comp,r as data};
