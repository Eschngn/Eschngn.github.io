---
icon: pen-to-square
date: 2025-06-27
star: 10
sticky: 10
category:
  - Java
tag:
  - Java基础
---
# Java 基础

## 数据类型

### 基本数据类型

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型： 
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`。

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值   | 取值范围                                                     | 示例             |
| :-------- | :--- | :--- | :------- | ------------------------------------------------------------ | ---------------- |
| `byte`    | 8    | 1    | 0        | -128 ~ 127                                                   | byte b = 10;     |
| `short`   | 16   | 2    | 0        | -32768（-2^15） ~ 32767（2^15 - 1）                          | short s=1000；   |
| `int`     | 32   | 4    | 0        | -2147483648 ~ 2147483647                                     | int i = 100;     |
| `long`    | 64   | 8    | 0L       | -9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1） | long l = 10000L; |
| `char`    | 16   | 2    | '\u0000' | 0 ~ 65535（2^16 - 1）                                        | char c = 'A';    |
| `float`   | 32   | 4    | 0.0f     | 1.4E-45 ~ 3.4028235E38，单精度，尾数约7位有效数字            | float f = 3.14f; |
| `double`  | 64   | 8    | 0.0d     | 4.9E-324 ~ 1.7976931348623157E308，双精度，尾数约15~16位有效数字 | double d = 3.1415926;  |
| `boolean` | 1    |      | false    | true、false                                                  | boolean b = true;  |

⚠️**注意：**

1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
2. Java 里使用 `float` 类型的数据一定要在数值后面加上 **f 或 F**，否则将无法通过编译。
3. `char a = 'h'`char :单引号，`String a = "hello"` :双引号。

### 包装类型

这八种基本类型对应的包装类型如下：

| 基本类型  | 包装类（位于 `java.lang` 包） |
| --------- | ----------------------------- |
| `byte`    | `Byte`                        |
| `short`   | `Short`                       |
| `int`     | `Integer`                     |
| `long`    | `Long`                        |
| `float`   | `Float`                       |
| `double`  | `Double`                      |
| `char`    | `Character`                   |
| `boolean` | `Boolean`                     |

包装类型的主要作用：

| 用途                         | 说明                                           |
| ---------------------------- | ---------------------------------------------- |
| **集合中使用**               | `List<int>` 是非法的，必须使用 `List<Integer>` |
| **泛型支持**                 | 泛型不支持基本类型，只能用包装类型             |
| **提供实用方法**             | 如 `Integer.parseInt("123")`、`Double.isNaN()` |
| **对象化处理**               | 在需要对象的地方（如反射）使用包装类           |
| **默认值处理（如 Map.get）** | 基本类型不能为 null，包装类型可以              |

包装类型的缓存机制

Java 中的包装类型缓存机制是一种性能优化手段，会对某些包装类的特定数值范围内的对象进行缓存（重用），避免频繁创建新对象。

比如当我们使用：

```java
Integer a = Integer.valueOf(100);
```

而不是：

```java
Integer a = new Integer(100);
```

时，`valueOf()` 方法可能会返回一个**缓存的对象**，而不是新建的。

📦缓存范围

| 包装类             | 缓存范围                   |
| ------------------ | -------------------------- |
| `Byte`             | -128 ~ 127                 |
| `Short`            | -128 ~ 127                 |
| `Integer`          | -128 ~ 127（默认，可配置） |
| `Long`             | -128 ~ 127                 |
| `Character`        | 0 ~ 127                    |
| `Boolean`          | true / false（两个对象）   |
| `Float` / `Double` | ❌ 没有缓存机制             |

> `Float` 和 `Double` 不采用缓存机制，是因为浮点数值的取值范围极广且精度分散，缓存意义不大，反而会浪费内存资源。

🧪 示例：Integer 缓存机制

```java
Integer x = 128;
Integer y = 128;
System.out.println(x == y);       // false （比较的是引用）

Integer a = 100;
Integer b = 100;
System.out.println(a == b);       // true（-128 到 127 缓存）

System.out.println(a.equals(b));  // true（比较值）
```

- `==` 比较的是地址（包装类型是对象引用）；
- `equals()` 比较的是值（包装类中已重写该方法）。

🛠️ Integer 缓存的实现源码

下面是 `Integer.java` 源码：

```java
public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127)  // 缓存范围
        return IntegerCache.cache[i + 128];
    else
        return new Integer(i);
}
```

`Integer` 缓存的上限可以通过 JVM 参数修改：

```ini
-Djava.lang.Integer.IntegerCache.high=1000
```

可将缓存范围改为 `-128 ~ 1000`。

### 两者联系与区别

自动装箱与自动拆箱

```java
int a = 10;                  // 基本类型
Integer b = a;               // 自动装箱（int → Integer）
int c = b;                   // 自动拆箱（Integer → int）
```

⚠️注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。

基本类型和包装类型的区别：

| 比较维度          | 基本类型（Primitive）    | 包装类型（Wrapper）         |
| ------------- | ------------------ | --------------------- |
| **是否是对象**     | ❌ 否                | ✅ 是，对象（类的实例）          |
| **存储位置**      | 栈内存                | 堆内存（引用）               |
| **默认值**       | 有（如 `int` 为 0）     | 可以为 `null`            |
| **使用范围**      | 不能用于泛型、集合等只支持对象的场景 | 可以用于集合、泛型等            |
| **性能**        | 更高（操作直接在栈上进行）      | 稍低（涉及对象创建与方法调用）       |
| **是否有方法**     | ❌ 没有任何方法           | ✅ 有丰富方法（如 `parseXXX`） |
| **是否支持 null** | ❌ 不支持 null         | ✅ 支持 null             |
| **使用场景**      | 一般用于高性能的数值计算场景     | 一般用于集合、框架、对象传递        |

## 浮点数运算的精度丢失

🌰举个例子：

```java
System.out.println(0.1 + 0.2);   // 输出：0.30000000000000004
```

我们期望输出是 `0.3`，但却出现了一个 **令人不爽的长小数**，这就是**精度丢失**问题。

这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。

就比如说十进制下的 0.2 就没办法精确转换成二进制小数：

```java
// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，
// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0（发生循环）
...
```

🔐 如何应对/解决浮点精度问题？

✅使用 `BigDecimal` 进行精确计算：

```java
import java.math.BigDecimal;

BigDecimal a = new BigDecimal("0.1");
BigDecimal b = new BigDecimal("0.2");
BigDecimal c = new BigDecimal("0.3");

System.out.println(a.add(b).equals(c));  // true

```

> ❗ 注意：用字符串构造 BigDecimal 更精确，**不要用 double 构造！**

## 运算符

### 自增自减运算符

自增 (++) 和自减 (--) 运算符 是一类常用的一元运算符，用于对变量的值进行 +1 或 -1 操作。它们可以放在变量的前面（前缀）或后面（后缀），但位置不同会导致表达式运算顺序不同。

| 表达式       | 含义说明              |
| --------- | ----------------- |
| `++x`（前缀） | 先将 `x` 加 1，再使用它的值 |
| `x++`（后缀） | 先使用 `x` 的原值，再加 1  |
| `--x`（前缀） | 先将 `x` 减 1，再使用它的值 |
| `x--`（后缀） | 先使用 `x` 的原值，再减 1  |

示例：

```java
int x = 5;
int a = ++x;  // x 先加 1 → x = 6，然后赋值给 a → a = 6
int b = x++;  // b 先得到 x 的值 6，然后 x 再加 1 → x = 7, b = 6

int y = 5;
int c = --y;  // y 先减 1 → y = 4，然后赋值给 c → c = 4
int d = y--;  // d 先得到 y 的值 4，然后 y 再减 1 → y = 3, d = 4

```

### 移位运算符

移位运算符（Shift Operators） 是对整数类型（二进制位）进行操作的一种运算符，适用于 byte、short、int、long 类型，主要用于高效的数值计算、加密压缩、位图处理等。

使用移位运算符的原因：

- 高效：现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。
- 节省内存：通过移位操作，可以使用一个整数（如 `int` 或 `long`）来存储多个布尔值或标志位，从而节省内存。

Java 中有三种移位运算符：

- `<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << n`,相当于 x 乘以 2 的 n 次方(不溢出的情况下)
- `>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> n`,相当于 x 除以 2 的 n 次方
- `>>>` :无符号右移，所有位向右移动，不保留符号位，高位补 0（仅适用于 int/long）

🌰举例说明

```java
int a = 8;         // 二进制：0000 1000
System.out.println(a << 1);   // 16（左移1位：0001 0000）
System.out.println(a >> 1);   // 4  （右移1位：0000 0100）
System.out.println(a >>> 1);  // 4  （和 >> 相同，因为正数符号位为0）

int b = -8;        // 二进制：1111 1000（补码表示）
System.out.println(b >> 1);   // -4（符号位为 1，保留，11111100）
System.out.println(b >>> 1);  // 2147483644（补 0，变成大正数 ，01111100）
```

⚠️注意：

- 当移位的位数超过数值所占有的位数，会先对相应位数求余（%）后再进行左移/右移操作（int 32位，long 64位）
- 移位不会改变变量本身（除非赋值）
- 移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作

## continue、break 和 return

在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：

1. `continue`：指跳出当前的这一次循环，继续下一次循环。
2. `break`：指跳出整个循环体，继续执行循环下面的语句。

`return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：

1. `return;`：直接使用 return 结束方法执行，用于没有返回值函数的方法
2. `return value;`：return 一个特定值，用于有返回值函数的方法

## 变量

成员变量与局部变量的区别：

| 比较项       | 成员变量                                                     | 局部变量                                           |
| ------------ | ------------------------------------------------------------ | -------------------------------------------------- |
| **定义位置** | 类中，方法外                                                 | 方法内部、构造器、代码块中                         |
| **默认值**   | ✅有，数值型为0，引用型为 null                                | ❌没有，必须手动初始化后才能使用                    |
| **存储位置** | 位于堆内存中，因为成员变量都属于对象的属性，静态成员变量（static修饰）是属于类级别的变量，它在堆内存中只有一个实例，被该类的所有实例共享 | 位于栈内存中，具体在 Java 虚拟机栈中的局部变量表中 |
| **生存周期** | 随对象创建而创建，随对象回收而消亡                           | 随方法调用创建，方法结束后销毁                     |

![成员变量与局部变量的区别](https://chengliuxiang.oss-cn-hangzhou.aliyuncs.com/picgo/variable-difference.png)

## 方法

静态方法为什么不能调用非静态成员？

这个需要结合 JVM 的相关知识，主要原因如下：

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

静态方法和实例方法有何不同？

**1、调用方式**

在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。

不过，需要注意的是一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。

因此，一般建议使用 `类名.方法名` 的方式来调用静态方法。

**2、访问类成员是否存在限制**

静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。



重载和重写的区别

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

- 重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理

- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。
  1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
  2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
  3. 构造方法无法被重写

## 修饰符

（1）public：修饰的类、方法和变量可以被任何其他类访问。

（2）private：不能用于顶级类（即非嵌套类），只能用于内部类；方法和变量只能在定义它的类内部访问。

（3）default：即不加任何访问修饰符，通常称为“默认访问模式“。修饰的类、方法和变量可以被同一包中的其他类访问。

（4）protected：不能用于顶级类（即非嵌套类），只能用于内部类；方法和变量可以被同一包中的其他类访问，也可以被不同包中的子类访问。

（5）static：`static` 修饰符用于表示类级别的成员，而不是实例级别的成员。也就是说，`static` 成员属于类，而不属于类的任何特定实例。

静态变量（类变量）：定义在类中的变量，如果用 `static` 修饰，则该变量是所有对象共享的。

```java
public class MyClass {
    public static int staticVar = 0;

    public void incrementStaticVar() {
        staticVar++;
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj1 = new MyClass();
        MyClass obj2 = new MyClass();
        
        obj1.incrementStaticVar();
        obj2.incrementStaticVar();

        System.out.println(MyClass.staticVar); // 输出：2
    }
}
```

静态方法：静态方法可以直接通过类名调用，不需要创建类的实例。静态方法不能访问实例变量和实例方法，只能访问静态变量和静态方法。

```java
public class MyClass {
    public static void staticMethod() {
        System.out.println("This is a static method.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass.staticMethod(); // 调用静态方法
    }
}
```

静态块：静态块用于初始化静态变量，在类加载时执行。

```java
public class MyClass {
    static {
        System.out.println("Static block executed.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass(); // 静态块在类加载时执行
    }
}
```

（6）final：`final` 修饰符用于表示常量、不可继承的类或不可重写的方法。

final变量：使用 `final` 修饰的变量不可改变，必须在声明时或通过构造方法初始化。

```java
public class MyClass {
    public final int finalVar = 10;

    public void changeFinalVar() {
        // finalVar = 20; // 错误：无法改变 final 变量
    }
}
```

final方法：使用 `final` 修饰的方法不能被子类重写。

```java
public class Parent {
    public final void finalMethod() {
        System.out.println("This method cannot be overridden.");
    }
}

public class Child extends Parent {
    // public void finalMethod() { // 错误：无法重写 final 方法
    // }
}
```

final类：使用 `final` 修饰的类不能被继承。

```java
public final class MyClass {
    // Class implementation
}

// public class SubClass extends MyClass { // 错误：无法继承 final 类
// }
```

（7）synchronized

`synchronized` 修饰符用于控制线程同步，以确保在同一时间只有一个线程可以访问某个代码块或方法。

（8）abstract

`abstract` 修饰符用于创建抽象类和抽象方法，抽象类不能被实例化，抽象方法没有方法体。

可变长参数

从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面这个方法就可以接受 0 个或者多个参数。

```java
public static void method1(String... args) {
   //......
}
```

另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。

```java
public static void method2(String arg1, String... args) {
   //......
}
```