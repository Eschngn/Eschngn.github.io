---
icon: pen-to-square
date: 2025-06-13
star: 10
sticky: 10
category:
  - Java
tag:
  - Java基础
---
# Java 基础

## 数据类型

### 基本数据类型

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型： 
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`。

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值   | 取值范围                                                     | 示例             |
| :-------- | :--- | :--- | :------- | ------------------------------------------------------------ | ---------------- |
| `byte`    | 8    | 1    | 0        | -128 ~ 127                                                   | byte b = 10;     |
| `short`   | 16   | 2    | 0        | -32768（-2^15） ~ 32767（2^15 - 1）                          | short s=1000；   |
| `int`     | 32   | 4    | 0        | -2147483648 ~ 2147483647                                     | int i = 100;     |
| `long`    | 64   | 8    | 0L       | -9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1） | long l = 10000L; |
| `char`    | 16   | 2    | '\u0000' | 0 ~ 65535（2^16 - 1）                                        | char c = 'A';    |
| `float`   | 32   | 4    | 0.0f     | 1.4E-45 ~ 3.4028235E38，单精度，尾数约7位有效数字            | float f = 3.14f; |
| `double`  | 64   | 8    | 0.0d     | 4.9E-324 ~ 1.7976931348623157E308，双精度，尾数约15~16位有效数字 | double d = 3.1415926;  |
| `boolean` | 1    |      | false    | true、false                                                  | boolean b = true;  |

⚠️**注意：**

1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
2. Java 里使用 `float` 类型的数据一定要在数值后面加上 **f 或 F**，否则将无法通过编译。
3. `char a = 'h'`char :单引号，`String a = "hello"` :双引号。

### 包装类型

这八种基本类型对应的包装类型如下：

| 基本类型  | 包装类（位于 `java.lang` 包） |
| --------- | ----------------------------- |
| `byte`    | `Byte`                        |
| `short`   | `Short`                       |
| `int`     | `Integer`                     |
| `long`    | `Long`                        |
| `float`   | `Float`                       |
| `double`  | `Double`                      |
| `char`    | `Character`                   |
| `boolean` | `Boolean`                     |

包装类型的主要作用：

| 用途                         | 说明                                           |
| ---------------------------- | ---------------------------------------------- |
| **集合中使用**               | `List<int>` 是非法的，必须使用 `List<Integer>` |
| **泛型支持**                 | 泛型不支持基本类型，只能用包装类型             |
| **提供实用方法**             | 如 `Integer.parseInt("123")`、`Double.isNaN()` |
| **对象化处理**               | 在需要对象的地方（如反射）使用包装类           |
| **默认值处理（如 Map.get）** | 基本类型不能为 null，包装类型可以              |

包装类型的缓存机制

Java 中的包装类型缓存机制是一种性能优化手段，会对某些包装类的特定数值范围内的对象进行缓存（重用），避免频繁创建新对象。

比如当我们使用：

```java
Integer a = Integer.valueOf(100);
```

而不是：

```java
Integer a = new Integer(100);
```

时，`valueOf()` 方法可能会返回一个**缓存的对象**，而不是新建的。

📦缓存范围

| 包装类             | 缓存范围                   |
| ------------------ | -------------------------- |
| `Byte`             | -128 ~ 127                 |
| `Short`            | -128 ~ 127                 |
| `Integer`          | -128 ~ 127（默认，可配置） |
| `Long`             | -128 ~ 127                 |
| `Character`        | 0 ~ 127                    |
| `Boolean`          | true / false（两个对象）   |
| `Float` / `Double` | ❌ 没有缓存机制             |

> `Float` 和 `Double` 不采用缓存机制，是因为浮点数值的取值范围极广且精度分散，缓存意义不大，反而会浪费内存资源。

🧪 示例：Integer 缓存机制

```java
Integer x = 128;
Integer y = 128;
System.out.println(x == y);       // false （比较的是引用）

Integer a = 100;
Integer b = 100;
System.out.println(a == b);       // true（-128 到 127 缓存）

System.out.println(a.equals(b));  // true（比较值）
```

- `==` 比较的是地址（包装类型是对象引用）；
- `equals()` 比较的是值（包装类中已重写该方法）。

🛠️ Integer 缓存的实现源码

下面是 `Integer.java` 源码：

```java
public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127)  // 缓存范围
        return IntegerCache.cache[i + 128];
    else
        return new Integer(i);
}
```

`Integer` 缓存的上限可以通过 JVM 参数修改：

```ini
-Djava.lang.Integer.IntegerCache.high=1000
```

可将缓存范围改为 `-128 ~ 1000`。

### 两者联系与区别

自动装箱与自动拆箱

```java
int a = 10;                  // 基本类型
Integer b = a;               // 自动装箱（int → Integer）
int c = b;                   // 自动拆箱（Integer → int）
```

⚠️注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。

基本类型和包装类型的区别：

| 比较维度          | 基本类型（Primitive）    | 包装类型（Wrapper）         |
| ------------- | ------------------ | --------------------- |
| **是否是对象**     | ❌ 否                | ✅ 是，对象（类的实例）          |
| **存储位置**      | 栈内存                | 堆内存（引用）               |
| **默认值**       | 有（如 `int` 为 0）     | 可以为 `null`            |
| **使用范围**      | 不能用于泛型、集合等只支持对象的场景 | 可以用于集合、泛型等            |
| **性能**        | 更高（操作直接在栈上进行）      | 稍低（涉及对象创建与方法调用）       |
| **是否有方法**     | ❌ 没有任何方法           | ✅ 有丰富方法（如 `parseXXX`） |
| **是否支持 null** | ❌ 不支持 null         | ✅ 支持 null             |
| **使用场景**      | 一般用于高性能的数值计算场景     | 一般用于集合、框架、对象传递        |

## 浮点数运算的精度丢失

🌰举个例子：

```java
System.out.println(0.1 + 0.2);   // 输出：0.30000000000000004
```

我们期望输出是 `0.3`，但却出现了一个 **令人不爽的长小数**，这就是**精度丢失**问题。

这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。

就比如说十进制下的 0.2 就没办法精确转换成二进制小数：

```java
// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，
// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0（发生循环）
...
```

🔐 如何应对/解决浮点精度问题？

✅使用 `BigDecimal` 进行精确计算：

```java
import java.math.BigDecimal;

BigDecimal a = new BigDecimal("0.1");
BigDecimal b = new BigDecimal("0.2");
BigDecimal c = new BigDecimal("0.3");

System.out.println(a.add(b).equals(c));  // true

```

> ❗ 注意：用字符串构造 BigDecimal 更精确，**不要用 double 构造！**

## 运算符

### 自增自减运算符

自增 (++) 和自减 (--) 运算符 是一类常用的一元运算符，用于对变量的值进行 +1 或 -1 操作。它们可以放在变量的前面（前缀）或后面（后缀），但位置不同会导致表达式运算顺序不同。

| 表达式       | 含义说明              |
| --------- | ----------------- |
| `++x`（前缀） | 先将 `x` 加 1，再使用它的值 |
| `x++`（后缀） | 先使用 `x` 的原值，再加 1  |
| `--x`（前缀） | 先将 `x` 减 1，再使用它的值 |
| `x--`（后缀） | 先使用 `x` 的原值，再减 1  |

示例：

```java
int x = 5;
int a = ++x;  // x 先加 1 → x = 6，然后赋值给 a → a = 6
int b = x++;  // b 先得到 x 的值 6，然后 x 再加 1 → x = 7, b = 6

int y = 5;
int c = --y;  // y 先减 1 → y = 4，然后赋值给 c → c = 4
int d = y--;  // d 先得到 y 的值 4，然后 y 再减 1 → y = 3, d = 4

```

### 移位运算符

移位运算符（Shift Operators） 是对整数类型（二进制位）进行操作的一种运算符，适用于 byte、short、int、long 类型，主要用于高效的数值计算、加密压缩、位图处理等。

使用移位运算符的原因：

- 高效：现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。
- 节省内存：通过移位操作，可以使用一个整数（如 `int` 或 `long`）来存储多个布尔值或标志位，从而节省内存。

Java 中有三种移位运算符：

- `<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << n`,相当于 x 乘以 2 的 n 次方(不溢出的情况下)
- `>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> n`,相当于 x 除以 2 的 n 次方
- `>>>` :无符号右移，所有位向右移动，不保留符号位，高位补 0（仅适用于 int/long）

🌰举例说明

```java
int a = 8;         // 二进制：0000 1000
System.out.println(a << 1);   // 16（左移1位：0001 0000）
System.out.println(a >> 1);   // 4  （右移1位：0000 0100）
System.out.println(a >>> 1);  // 4  （和 >> 相同，因为正数符号位为0）

int b = -8;        // 二进制：1111 1000（补码表示）
System.out.println(b >> 1);   // -4（符号位为 1，保留，11111100）
System.out.println(b >>> 1);  // 2147483644（补 0，变成大正数 ，01111100）
```

⚠️注意：

- 当移位的位数超过数值所占有的位数，会先对相应位数求余（%）后再进行左移/右移操作（int 32位，long 64位）
- 移位不会改变变量本身（除非赋值）
- 移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作

