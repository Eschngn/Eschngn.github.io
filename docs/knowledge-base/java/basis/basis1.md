---
title: 基础知识1
star: 10
sticky: 10
category:
  - Java
tag:
  - Java基础
---

## 数据类型

### 基本数据类型

Java 中有 8 种基本数据类型，分别为：

- 6 种数字类型： 
  - 4 种整数型：`byte`、`short`、`int`、`long`
  - 2 种浮点型：`float`、`double`
- 1 种字符类型：`char`
- 1 种布尔型：`boolean`。

这 8 种基本数据类型的默认值以及所占空间的大小如下：

| 基本类型  | 位数 | 字节 | 默认值   | 取值范围                                                     | 示例             |
| :-------- | :--- | :--- | :------- | ------------------------------------------------------------ | ---------------- |
| `byte`    | 8    | 1    | 0        | -128 ~ 127                                                   | byte b = 10;     |
| `short`   | 16   | 2    | 0        | -32768（-2^15） ~ 32767（2^15 - 1）                          | short s=1000；   |
| `int`     | 32   | 4    | 0        | -2147483648 ~ 2147483647                                     | int i = 100;     |
| `long`    | 64   | 8    | 0L       | -9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1） | long l = 10000L; |
| `char`    | 16   | 2    | '\u0000' | 0 ~ 65535（2^16 - 1）                                        | char c = 'A';    |
| `float`   | 32   | 4    | 0.0f     | 1.4E-45 ~ 3.4028235E38，单精度，尾数约7位有效数字            | float f = 3.14f; |
| `double`  | 64   | 8    | 0.0d     | 4.9E-324 ~ 1.7976931348623157E308，双精度，尾数约15~16位有效数字 | double d = 3.1415926;  |
| `boolean` | 1    |      | false    | true、false                                                  | boolean b = true;  |

⚠️**注意：**

1. Java 里使用 `long` 类型的数据一定要在数值后面加上 **L**，否则将作为整型解析。
2. Java 里使用 `float` 类型的数据一定要在数值后面加上 **f 或 F**，否则将无法通过编译。
3. `char a = 'h'`char :单引号，`String a = "hello"` :双引号。

### 包装类型

这八种基本类型对应的包装类型如下：

| 基本类型  | 包装类（位于 `java.lang` 包） |
| --------- | ----------------------------- |
| `byte`    | `Byte`                        |
| `short`   | `Short`                       |
| `int`     | `Integer`                     |
| `long`    | `Long`                        |
| `float`   | `Float`                       |
| `double`  | `Double`                      |
| `char`    | `Character`                   |
| `boolean` | `Boolean`                     |

包装类型的主要作用：

| 用途                         | 说明                                           |
| ---------------------------- | ---------------------------------------------- |
| **集合中使用**               | `List<int>` 是非法的，必须使用 `List<Integer>` |
| **泛型支持**                 | 泛型不支持基本类型，只能用包装类型             |
| **提供实用方法**             | 如 `Integer.parseInt("123")`、`Double.isNaN()` |
| **对象化处理**               | 在需要对象的地方（如反射）使用包装类           |
| **默认值处理（如 Map.get）** | 基本类型不能为 null，包装类型可以              |

包装类型的缓存机制

Java 中的包装类型缓存机制是一种性能优化手段，会对某些包装类的特定数值范围内的对象进行缓存（重用），避免频繁创建新对象。

比如当我们使用：

```java
Integer a = Integer.valueOf(100);
```

而不是：

```java
Integer a = new Integer(100);
```

时，`valueOf()` 方法可能会返回一个**缓存的对象**，而不是新建的。

📦缓存范围

| 包装类             | 缓存范围                   |
| ------------------ | -------------------------- |
| `Byte`             | -128 ~ 127                 |
| `Short`            | -128 ~ 127                 |
| `Integer`          | -128 ~ 127（默认，可配置） |
| `Long`             | -128 ~ 127                 |
| `Character`        | 0 ~ 127                    |
| `Boolean`          | true / false（两个对象）   |
| `Float` / `Double` | ❌ 没有缓存机制             |

> `Float` 和 `Double` 不采用缓存机制，是因为浮点数值的取值范围极广且精度分散，缓存意义不大，反而会浪费内存资源。

🧪 示例：Integer 缓存机制

```java
Integer x = 128;
Integer y = 128;
System.out.println(x == y);       // false （比较的是引用）

Integer a = 100;
Integer b = 100;
System.out.println(a == b);       // true（-128 到 127 缓存）

System.out.println(a.equals(b));  // true（比较值）
```

- `==` 比较的是地址（包装类型是对象引用）；
- `equals()` 比较的是值（包装类中已重写该方法）。

🛠️ Integer 缓存的实现源码

下面是 `Integer.java` 源码：

```java
public static Integer valueOf(int i) {
    if (i >= -128 && i <= 127)  // 缓存范围
        return IntegerCache.cache[i + 128];
    else
        return new Integer(i);
}
```

`Integer` 缓存的上限可以通过 JVM 参数修改：

```ini
-Djava.lang.Integer.IntegerCache.high=1000
```

可将缓存范围改为 `-128 ~ 1000`。

### 两者联系与区别

自动装箱与自动拆箱

```java
int a = 10;                  // 基本类型
Integer b = a;               // 自动装箱（int → Integer）
int c = b;                   // 自动拆箱（Integer → int）
```

⚠️注意：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。

基本类型和包装类型的区别：

| 比较维度          | 基本类型（Primitive）    | 包装类型（Wrapper）         |
| ------------- | ------------------ | --------------------- |
| **是否是对象**     | ❌ 否                | ✅ 是，对象（类的实例）          |
| **存储位置**      | 栈内存                | 堆内存（引用）               |
| **默认值**       | 有（如 `int` 为 0）     | 可以为 `null`            |
| **使用范围**      | 不能用于泛型、集合等只支持对象的场景 | 可以用于集合、泛型等            |
| **性能**        | 更高（操作直接在栈上进行）      | 稍低（涉及对象创建与方法调用）       |
| **是否有方法**     | ❌ 没有任何方法           | ✅ 有丰富方法（如 `parseXXX`） |
| **是否支持 null** | ❌ 不支持 null         | ✅ 支持 null             |
| **使用场景**      | 一般用于高性能的数值计算场景     | 一般用于集合、框架、对象传递        |

## 浮点数运算的精度丢失

🌰举个例子：

```java
System.out.println(0.1 + 0.2);   // 输出：0.30000000000000004
```

我们期望输出是 `0.3`，但却出现了一个 **令人不爽的长小数**，这就是**精度丢失**问题。

这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。

就比如说十进制下的 0.2 就没办法精确转换成二进制小数：

```java
// 0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，
// 在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0（发生循环）
...
```

🔐 如何应对/解决浮点精度问题？

✅使用 `BigDecimal` 进行精确计算：

```java
import java.math.BigDecimal;

BigDecimal a = new BigDecimal("0.1");
BigDecimal b = new BigDecimal("0.2");
BigDecimal c = new BigDecimal("0.3");

System.out.println(a.add(b).equals(c));  // true

```

> ❗ 注意：用字符串构造 BigDecimal 更精确，**不要用 double 构造！**

## 运算符

### 自增自减运算符

自增 (++) 和自减 (--) 运算符 是一类常用的一元运算符，用于对变量的值进行 +1 或 -1 操作。它们可以放在变量的前面（前缀）或后面（后缀），但位置不同会导致表达式运算顺序不同。

| 表达式       | 含义说明              |
| --------- | ----------------- |
| `++x`（前缀） | 先将 `x` 加 1，再使用它的值 |
| `x++`（后缀） | 先使用 `x` 的原值，再加 1  |
| `--x`（前缀） | 先将 `x` 减 1，再使用它的值 |
| `x--`（后缀） | 先使用 `x` 的原值，再减 1  |

示例：

```java
int x = 5;
int a = ++x;  // x 先加 1 → x = 6，然后赋值给 a → a = 6
int b = x++;  // b 先得到 x 的值 6，然后 x 再加 1 → x = 7, b = 6

int y = 5;
int c = --y;  // y 先减 1 → y = 4，然后赋值给 c → c = 4
int d = y--;  // d 先得到 y 的值 4，然后 y 再减 1 → y = 3, d = 4

```

### 移位运算符

移位运算符（Shift Operators） 是对整数类型（二进制位）进行操作的一种运算符，适用于 byte、short、int、long 类型，主要用于高效的数值计算、加密压缩、位图处理等。

使用移位运算符的原因：

- 高效：现代处理器具有专门的硬件指令来执行这些移位操作，这些指令通常在一个时钟周期内完成。相比之下，乘法和除法等算术运算在硬件层面上需要更多的时钟周期来完成。
- 节省内存：通过移位操作，可以使用一个整数（如 `int` 或 `long`）来存储多个布尔值或标志位，从而节省内存。

Java 中有三种移位运算符：

- `<<` :左移运算符，向左移若干位，高位丢弃，低位补零。`x << n`,相当于 x 乘以 2 的 n 次方(不溢出的情况下)
- `>>` :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。`x >> n`,相当于 x 除以 2 的 n 次方
- `>>>` :无符号右移，所有位向右移动，不保留符号位，高位补 0（仅适用于 int/long）

🌰举例说明

```java
int a = 8;         // 二进制：0000 1000
System.out.println(a << 1);   // 16（左移1位：0001 0000）
System.out.println(a >> 1);   // 4  （右移1位：0000 0100）
System.out.println(a >>> 1);  // 4  （和 >> 相同，因为正数符号位为0）

int b = -8;        // 二进制：1111 1000（补码表示）
System.out.println(b >> 1);   // -4（符号位为 1，保留，11111100）
System.out.println(b >>> 1);  // 2147483644（补 0，变成大正数 ，01111100）
```

⚠️注意：

- 当移位的位数超过数值所占有的位数，会先对相应位数求余（%）后再进行左移/右移操作（int 32位，long 64位）
- 移位不会改变变量本身（除非赋值）
- 移位操作符实际上支持的类型只有`int`和`long`，编译器在对`short`、`byte`、`char`类型进行移位前，都会将其转换为`int`类型再操作

## continue、break 和 return

在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：

1. `continue`：指跳出当前的这一次循环，继续下一次循环。
2. `break`：指跳出整个循环体，继续执行循环下面的语句。

`return` 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：

1. `return;`：直接使用 return 结束方法执行，用于没有返回值函数的方法
2. `return value;`：return 一个特定值，用于有返回值函数的方法

## 变量

成员变量与局部变量的区别：

| 比较项       | 成员变量                                                     | 局部变量                                           |
| ------------ | ------------------------------------------------------------ | -------------------------------------------------- |
| **定义位置** | 类中，方法外                                                 | 方法内部、构造器、代码块中                         |
| **默认值**   | ✅有，数值型为0，引用型为 null                                | ❌没有，必须手动初始化后才能使用                    |
| **存储位置** | 位于堆内存中，因为成员变量都属于对象的属性，静态成员变量（static修饰）是属于类级别的变量，它在堆内存中只有一个实例，被该类的所有实例共享 | 位于栈内存中，具体在 Java 虚拟机栈中的局部变量表中 |
| **生存周期** | 随对象创建而创建，随对象回收而消亡                           | 随方法调用创建，方法结束后销毁                     |

![成员变量与局部变量的区别](https://chengliuxiang.oss-cn-hangzhou.aliyuncs.com/picgo/variable-difference.png)

## 方法

静态方法为什么不能调用非静态成员？

这个需要结合 JVM 的相关知识，主要原因如下：

1. 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。
2. 在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

静态方法和实例方法有何不同？

**1、调用方式**

在外部调用静态方法时，可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，而实例方法只有后面这种方式。也就是说，**调用静态方法可以无需创建对象** 。

不过，需要注意的是一般不建议使用 `对象.方法名` 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。

因此，一般建议使用 `类名.方法名` 的方式来调用静态方法。

**2、访问类成员是否存在限制**

静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。



重载和重写的区别

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

- 重载发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理

- 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。
  1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
  2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
  3. 构造方法无法被重写

## `==` 和 `equals`

### `==` 运算符

`==` 运算符是一个关系运算符，对于基本类型和引用类型的作用效果是不同的

- 对于基本数据类型来说，`==` 比较的是值。

  ```java
  int a = 10;
  int b = 10;
  int c = 20;
  
  System.out.println(a == b); // true (值相等)
  System.out.println(a == c); // false (值不相等)
  ```

- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

  ```java
  String s1 = new String("Hello");
  String s2 = new String("Hello"); // s1 和 s2 是两个不同的String对象
  String s3 = s1;                 // s3 和 s1 指向同一个String对象
  
  System.out.println(s1 == s2); // false (s1 和 s2 指向不同的内存地址)
  System.out.println(s1 == s3); // true (s1 和 s3 指向同一个内存地址)
  
  // 对于包装类型，== 的行为还会受到缓存机制的影响
  Integer i1 = 100; // 自动装箱，100在Integer的缓存范围内
  Integer i2 = 100; // 自动装箱，100在Integer的缓存范围内
  Integer i3 = 200; // 自动装箱，200超出Integer的缓存范围
  Integer i4 = 200; // 自动装箱，200超出Integer的缓存范围
  
  System.out.println(i1 == i2); // true (因为100在缓存范围内，通常会指向同一个对象)
  System.out.println(i3 == i4); // false (因为200超出缓存范围，会创建两个新对象)
  
  // 注意：Float 和 Double 没有缓存机制，即使值相同，== 也会是 false。
  Float f1 = 1.0f;
  Float f2 = 1.0f;
  System.out.println(f1 == f2); // false
  ```

> 因为 Java 只有值传递，所以，对于 `==` 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

### `equals()` 方法

`equals()` 方法是 `java.lang.Object` 类中的一个方法，它被设计用来比较两个对象的**内容**是否相等。

1. `Object` 类中 `equals()` 的默认实现：在 `Object` 类中，`equals()` 方法的默认实现与 `==` 运算符的行为**完全相同**，即它也比较的是对象的**引用地址**。

   `Object` 类中 `equals()` 方法：
   
    ```java
   public boolean equals(Object obj) {
        return (this == obj);
    }
   ```

   ```java
   Object o1 = new Object();
   Object o2 = new Object();
   System.out.println(o1.equals(o2)); // false (默认行为是比较地址)
   ```

2. 被重写 (Override) 的 `equals()` 方法：许多 Java 核心库中的类（例如 `String`、`Integer`、`ArrayList` 等）都**重写了 `equals()` 方法**，以提供基于**内容**的比较逻辑。

   - `String` 类的 `equals()`：比较字符串的**字符序列**是否相同。

     ```java
     String s1 = new String("Hello");
     String s2 = new String("Hello");
     String s3 = "World";
     
     System.out.println(s1.equals(s2)); // true (内容相等)
     System.out.println(s1.equals(s3)); // false
     ```

   - `Integer` 类的 `equals()`：比较包装的整数**值**是否相同。

     ```java
     Integer i1 = new Integer(100); // 尽管现在不推荐直接使用new Integer()
     Integer i2 = new Integer(100);
     Integer i3 = 200;
     Integer i4 = 200;
     
     System.out.println(i1.equals(i2)); // true (值相等)
     System.out.println(i3.equals(i4)); // true (值相等)
     ```

   - 自定义类重写 `equals()`：如果是自己定义的类需要进行基于内容的比较，那么**必须**重写 `equals()` 方法（通常也需要同时重写 `hashCode()` 方法，以满足 `equals` 和 `hashCode` 的通用约定）。

     ```java
     class MyPoint {
         int x;
         int y;
     
         public MyPoint(int x, int y) {
             this.x = x;
             this.y = y;
         }
     
         @Override
         public boolean equals(Object obj) {
             // 1. 检查是否为同一个对象
             if (this == obj) return true;
             // 2. 检查传入对象是否为空或类型不匹配
             if (obj == null || getClass() != obj.getClass()) return false;
             // 3. 类型转换
             MyPoint other = (MyPoint) obj;
             // 4. 比较关键字段的内容
             return x == other.x && y == other.y;
         }
     
         // 同时重写 hashCode()
         @Override
         public int hashCode() {
             return Objects.hash(x, y);
         }
     }
     
     MyPoint p1 = new MyPoint(1, 2);
     MyPoint p2 = new MyPoint(1, 2);
     MyPoint p3 = new MyPoint(3, 4);
     
     System.out.println(p1 == p2);       // false (不同对象)
     System.out.println(p1.equals(p2));  // true (内容相等，因为我们重写了equals)
     System.out.println(p1.equals(p3));  // false
     ```

## `hashCode()` 方法

`hashCode()` 方法是 `java.lang.Object` 类中的一个方法，它返回该对象的哈希码（hash code）值。哈希码是一个整数，它在散列数据结构（如 `HashMap`、`HashSet`、`HashTable`）中起着提高查找对象效率的作用。

> 以 `HashSet` 为例，当我们把对象存入 `HashSet` 时，会先计算出对象的 `hashCode` 来得到对象在底层数组中存储的 “桶” 的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

以上也便是 JDK 同时提供 `hashCode()` 和 `equals()` 方法的原因。

在 `Object` 类中，`hashCode()` 的默认实现通常会将对象的**内存地址**转换为一个整数。这意味着，即使两个不同的对象内容完全相同，它们的哈希码也可能是不同的（因为它们在内存中的地址不同）。

因此，Java 规范对这两个方法定义了非常重要的**约定（Contract）**：

1. **如果两个对象根据 `equals(Object obj)` 方法是相等的，那么调用这两个对象中任意一个的 `hashCode()` 方法都必须产生相同的整数结果。**
   - **理解：** 如果我们认为两个对象是“一样”的（通过 `equals` 比较），那么它们的哈希码就**必须一样**。否则，我们将无法在哈希表中正确地查找这些对象。
   例如，如果我们把一个 `MyObject A` 存入 `HashSet`，然后用一个与 `A` `equals` 的 `MyObject B` 去查找 ，如果 `A` 和 `B` 的 `hashCode` 不同，`HashSet` 定位到不同的存储桶中，导致找不到 `A`。
   删除对象也是同理，我们可能无法通过一个逻辑上相等的对象来删除另一个对象，因为 `HashSet` 会基于 `hashCode()` 查找错误的存储桶。
2. **如果两个对象根据 `equals(Object obj)` 方法是不相等的，那么调用这两个对象中任意一个的 `hashCode()` 方法不要求产生不同的整数结果。**
   - **理解：** 两个不相等的对象可以有相同的哈希码。这种情况被称为**哈希冲突（hash collision）**。哈希冲突是允许的，但冲突越少越好，因为它会降低哈希表的性能（需要进一步比较 `equals`）。
3. **在应用程序执行期间，只要一个对象的 `equals()` 比较中所用的信息没有被修改，那么对该对象多次调用 `hashCode()` 方法都必须始终返回相同的整数结果。**
   - **理解：** 哈希码必须是**稳定的**。如果一个对象的哈希码在使用过程中会发生变化，那么当它被放入哈希表后，你可能就无法再找到它了。

所以，我们在重写 `equals()` 方法的同时，也要重写 `hashCode()` 方法，以满足 `equals` 和 `hashCode` 的通用约定。